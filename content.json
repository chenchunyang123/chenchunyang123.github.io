{"meta":{"title":"一条放了盐的鱼","subtitle":"web搬砖大师","description":"前端博客，笔记，解决方案","author":"陈春阳","url":"http://chenchunyang.site","root":"/"},"pages":[{"title":"所有分类","date":"2019-12-23T15:34:20.222Z","updated":"2019-12-23T15:34:20.222Z","comments":true,"path":"categories/index.html","permalink":"http://chenchunyang.site/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-12-23T15:33:56.548Z","updated":"2019-12-23T15:33:56.548Z","comments":true,"path":"about/index.html","permalink":"http://chenchunyang.site/about/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-12-23T15:35:16.135Z","updated":"2019-12-23T15:35:16.135Z","comments":true,"path":"friends/index.html","permalink":"http://chenchunyang.site/friends/index.html","excerpt":"","text":""},{"title":"","date":"2019-12-23T15:37:17.859Z","updated":"2019-12-23T15:37:17.859Z","comments":true,"path":"projects/index.html","permalink":"http://chenchunyang.site/projects/index.html","excerpt":"","text":"作品页"},{"title":"所有标签","date":"2019-12-24T10:00:03.559Z","updated":"2019-12-24T10:00:03.559Z","comments":true,"path":"tags/index.html","permalink":"http://chenchunyang.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"腾讯云服务器（win）开启node后台服务流程及问题","slug":"15-Start-the-node-service","date":"2019-12-04T09:19:32.695Z","updated":"2019-12-25T08:00:41.844Z","comments":true,"path":"2019/12/04/15-Start-the-node-service/","link":"","permalink":"http://chenchunyang.site/2019/12/04/15-Start-the-node-service/","excerpt":"这两天趁着腾讯云有活动，买了一年的入门级云服务器的使用权限，打算用 node 写一些后台，正好也练习练习 node，话不多说，开始折腾！！ 登录远程服务器1、在实例中，找到刚刚购买的服务器（没开机的先开机）","text":"这两天趁着腾讯云有活动，买了一年的入门级云服务器的使用权限，打算用 node 写一些后台，正好也练习练习 node，话不多说，开始折腾！！ 登录远程服务器1、在实例中，找到刚刚购买的服务器（没开机的先开机） 2、点击右侧的登录按钮 3、因为我是 windows 的系统，这里选择第一种方式（如果你是其他的系统或者登录上有什么问题，可以点击上图中蓝色的字查看官方文档），然后会下载一个 rdp 文件到你的电脑中，之后双击这个文件，输入登录密码登录，密码的设置和重置这里不再说明，需要请查看官方文档 4、输入正确的密码之后，我们就成功连接进来了，可以进行下一步操作了 配置远程服务器 node以下都是在远程链接界面中进行： 1、首先下载 node 安装包，在官网选择与系统对应的版本，下载地址：http://nodejs.cn/download/ 2、安装 node（不再详细介绍，主要一点是里面有一项 addtopath 需要勾选上，意思是添加到环境变量，那么你在磁盘的任意位置都可以使用 node 命令） 写 node 接口下载一个常用的编辑器写 node，我下载的是 vscode。1、首先在一个空文件夹下创建 app.js 文件，然后写入以下代码 1let express = require('express'); // 需安装模块npm install express2let app = express(); // 实例化app3app.get('/person', (req, res) =&gt; &#123;4 // 接口5 res.json(&#123;6 name: '小明',7 age: 228 &#125;);9&#125;);10app.listen(80, () =&gt; &#123;11 // 监听80端口12 console.log('监听80端口');13&#125;); 2、然后 vscode 的终端中开启 node 服务（命令：node [文件名].js）（不要忽略上一步中安装 express 的操作） 配置云服务器安全组因为我们想通过 80 端口，从别的机器上访问到/person 这个接口，那么我们就需要进行安全组配置，定义入站出站规则。1、打开之前云服务器后台界面，点击左侧安全组选项，然后在自己服务器的区域选项下点击新建按钮，再选择放通全部端口 2、然后我们需要关联服务器，点击管理实例，新增关联，选择服务器，确定 3、这些配置完成后，我们就可以在自己电脑上的浏览器通过服务器的公网 ip 成功访问到该接口了 注意问题1、如果你的安全组并不想开启全部端口，只想开启需要的，那么记的在远程服务器开启 node 服务的端口号一定要在安全组里面配置，否则会出现连接超时。2、node 服务的端口号并不能任意设置，某些端口号会让部分浏览器访问时报错（ERR_UNSAFE_PORT），可以理解为一种安全策略，以下这些端口号应避免使用： 1, // tcpmux7, // echo9, // discard11, // systat13, // daytime15, // netstat17, // qotd19, // chargen20, // ftp data21, // ftp access22, // ssh23, // telnet25, // smtp37, // time42, // name43, // nicname53, // domain77, // priv-rjs79, // finger87, // ttylink95, // supdup101, // hostriame102, // iso-tsap103, // gppitnp104, // acr-nema109, // pop2110, // pop3111, // sunrpc113, // auth115, // sftp117, // uucp-path119, // nntp123, // NTP135, // loc-srv /epmap139, // netbios143, // imap2179, // BGP389, // ldap465, // smtp+ssl512, // print / exec513, // login514, // shell515, // printer526, // tempo530, // courier531, // chat532, // netnews540, // uucp556, // remotefs563, // nntp+ssl587, // stmp?601, // ??636, // ldap+ssl993, // ldap+ssl995, // pop3+ssl2049, // nfs3659, // apple-sasl / PasswordServer4045, // lockd6000, // X116665, // Alternate IRC [Apple addition]6666, // Alternate IRC [Apple addition]6667, // Standard IRC [Apple addition]6668, // Alternate IRC [Apple addition]6669, // Alternate IRC [Apple addition]","categories":[{"name":"云服务器","slug":"云服务器","permalink":"http://chenchunyang.site/categories/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"node","slug":"node","permalink":"http://chenchunyang.site/tags/node/"}]},{"title":"我的收藏","slug":"14-My-collection","date":"2019-09-02T08:20:48.000Z","updated":"2019-12-25T08:00:32.797Z","comments":true,"path":"2019/09/02/14-My-collection/","link":"","permalink":"http://chenchunyang.site/2019/09/02/14-My-collection/","excerpt":"学习项目 可视化学习 git：https://learngitbranching.js.org/ 可视化学习 flex 布局：http://flexboxfroggy.com/#zh-cn 实用库 vis 可视化库：https://visjs.org/index.html （易上手，配置丰富，用来实现有向图不错） js 函数工具库：https://www.lodashjs.com/ （丰富的 api，封装了很多常用的工具函数）","text":"学习项目 可视化学习 git：https://learngitbranching.js.org/ 可视化学习 flex 布局：http://flexboxfroggy.com/#zh-cn 实用库 vis 可视化库：https://visjs.org/index.html （易上手，配置丰富，用来实现有向图不错） js 函数工具库：https://www.lodashjs.com/ （丰富的 api，封装了很多常用的工具函数） 好文 数据结构和算法：https://juejin.im/post/5d5b307b5188253da24d3cd1#heading-51 （有学习路径，有案例）","categories":[{"name":"收藏","slug":"收藏","permalink":"http://chenchunyang.site/categories/%E6%94%B6%E8%97%8F/"}],"tags":[{"name":"实用库","slug":"实用库","permalink":"http://chenchunyang.site/tags/%E5%AE%9E%E7%94%A8%E5%BA%93/"},{"name":"好文","slug":"好文","permalink":"http://chenchunyang.site/tags/%E5%A5%BD%E6%96%87/"}]},{"title":"hook实现todolist","slug":"13-Implementing-applications-with-hook","date":"2019-07-09T07:04:48.000Z","updated":"2019-12-26T09:14:27.214Z","comments":true,"path":"2019/07/09/13-Implementing-applications-with-hook/","link":"","permalink":"http://chenchunyang.site/2019/07/09/13-Implementing-applications-with-hook/","excerpt":"背景最近不是特别忙，所以想学一点新的东西充实一下自己，毕竟程序员这个职业就是要不断学习。又打算学学 hook 是因为 vue3.0 计划废除 class 相关 api 而使用 hook，并且 react 中 hook 正式推出也有一段时间了，就让我对这个 hook 语法很好奇，它到底是何方神圣。这篇文章本来是打算记录一些 hook 的使用规则，用法，概念性的东西，但是在 react 的官方文档上，对 hook 语法的描述已经很清楚了！在这里就不再赘述，主要想记录一下自己用 hook 实现 todolist 的思路。","text":"背景最近不是特别忙，所以想学一点新的东西充实一下自己，毕竟程序员这个职业就是要不断学习。又打算学学 hook 是因为 vue3.0 计划废除 class 相关 api 而使用 hook，并且 react 中 hook 正式推出也有一段时间了，就让我对这个 hook 语法很好奇，它到底是何方神圣。这篇文章本来是打算记录一些 hook 的使用规则，用法，概念性的东西，但是在 react 的官方文档上，对 hook 语法的描述已经很清楚了！在这里就不再赘述，主要想记录一下自己用 hook 实现 todolist 的思路。 实现思路项目结构1|-- react-hook &#x2F;&#x2F; 项目文件夹2 |-- .eslintrc &#x2F;&#x2F; 检验hook语法3 |-- .gitignore4 |-- package.json5 |-- README.md6 |-- yarn.lock7 |-- build &#x2F;&#x2F; 打包后的文件8 |-- public &#x2F;&#x2F; 打包会直接输出的文件9 | |-- favicon.ico10 | |-- index.html11 | |-- manifest.json12 |-- src13 |-- App.css14 |-- App.js &#x2F;&#x2F; todolist容器15 |-- index.css16 |-- index.js &#x2F;&#x2F; 入口文件17 |-- components18 |-- FilterOptions &#x2F;&#x2F; 选项组件（底部）19 | |-- index.css20 | |-- index.js21 |-- InputBox &#x2F;&#x2F; 输入组件（顶部）22 | |-- index.css23 | |-- index.js24 |-- List &#x2F;&#x2F; 列表组件（中部）25 |-- index.css26 |-- index.js 代码详情App.js1import React, &#123; useState &#125; from &#39;react&#39;;2import &#39;.&#x2F;App.css&#39;;34&#x2F;&#x2F; 引入相关组件5import InputBox from &#39;.&#x2F;components&#x2F;InputBox&#39;;6import List from &#39;.&#x2F;components&#x2F;List&#39;;7import FilterOptions from &#39;.&#x2F;components&#x2F;FilterOptions&#39;;89function App() &#123;10 &#x2F;&#x2F; 定义所有的state11 const [inputValue, setValue] &#x3D; useState(&#39;&#39;); &#x2F;&#x2F; 输入内容相关12 const [todoThings, setTodo] &#x3D; useState([&#123; id: 1, text: &#39;学习hook&#39;, done: true &#125;]); &#x2F;&#x2F; 待办事项列表相关13 const [renderValue, setRenderValue] &#x3D; useState(1); &#x2F;&#x2F; 1为全部， 2为已完成， 3为未完成1415 &#x2F;&#x2F; 往下穿的对象16 const InputBoxProps &#x3D; &#123;17 inputValue,18 setValue,19 todoThings,20 setTodo,21 &#125;22 const ListProps &#x3D; &#123;23 renderValue,24 todoThings,25 setTodo,26 &#125;27 const optionsProps &#x3D; &#123;28 renderValue,29 setRenderValue,30 &#125;3132 return (33 &lt;div className&#x3D;&#39;box&#39;&gt;34 &lt;h2&gt;TODO计划表&lt;&#x2F;h2&gt;35 &lt;InputBox &#123;...InputBoxProps&#125; &#x2F;&gt;36 &lt;List &#123;...ListProps&#125; &#x2F;&gt;37 &lt;FilterOptions &#123;...optionsProps&#125; &#x2F;&gt;38 &lt;&#x2F;div&gt;39 );40&#125;4142export default App; 该文件是整个 app 的容器文件，从上到下依次引入了 3 个组件（InputBox、List、FilterOptions），然后利用 hook 的 api 定义了 3 种 state 数据，再根据不同组件与 state 数据之间的联系，把 state 传到相应的组件中去。 InputBox.js1import React from &#39;react&#39;;23&#x2F;&#x2F; 添加一项的方法(参数： 输入框当前值和list事项的值)4const addOne &#x3D; (value, all) &#x3D;&gt; &#123;5 return [...all, &#123; id: new Date().getTime(), text: value, done: false &#125;];6&#125;78function InputBox(props) &#123;9 let &#123; inputValue, setValue, todoThings, setTodo &#125; &#x3D; props;10 return (11 &lt;div&gt;12 &lt;input13 placeholder&#x3D;&#39;请输入待办事项&#39;14 type&#x3D;&#39;text&#39;15 value&#x3D;&#123;inputValue&#125;16 onChange&#x3D;&#123;e &#x3D;&gt; setValue(e.target.value)&#125;17 &#x2F;&gt;18 &lt;button19 onClick&#x3D;&#123;() &#x3D;&gt; &#123;20 inputValue &amp;&amp; setTodo(addOne(inputValue, todoThings))21 &#x2F;&#x2F; 增加完过后清空输入框22 setValue(&#39;&#39;)23 &#125;&#125;24 &gt;ADD&lt;&#x2F;button&gt;25 &lt;&#x2F;div&gt;26 );27&#125;2829export default InputBox; 输入框中内容的改变需要一个输入文本数据，点击添加按钮是把文本数据添加到 list 展示数据的 state 里面去，所以需要 list 的 state 数据。再加上他们 2 个对应的改变值的方法，所以这个组件需要接收 4 个数据。 FilterOptions.js1import React from &#39;react&#39;;2import &#39;.&#x2F;index.css&#39;;34const renderArr &#x3D; [&#39;全部&#39;, &#39;已完成&#39;, &#39;未完成&#39;]; &#x2F;&#x2F; 定义出来简化书写56function FilterOptions(props) &#123;7 let &#123; renderValue, setRenderValue &#125; &#x3D; props;8 return (9 &lt;div className&#x3D;&#39;options&#39;&gt;10 &#123;11 renderArr.map((item, idx) &#x3D;&gt; &#123;12 return (13 &lt;button14 key&#x3D;&#123;idx&#125;15 style&#x3D;&#123;&#123;backgroundColor: renderValue &#x3D;&#x3D;&#x3D; idx + 1 ? &#39;orange&#39; : null&#125;&#125;16 onClick&#x3D;&#123;() &#x3D;&gt; setRenderValue(idx + 1)&#125;17 &gt;&#123;item&#125;&lt;&#x2F;button&gt;18 )19 &#125;)20 &#125;21 &lt;&#x2F;div&gt;22 )23&#125;2425export default FilterOptions; 该组件的实现思路是改变 state 中的一个‘信号量’，当该信号量为 1 时，list 组件里面渲染全部事件，当为 2 时渲染已完成，当为 3 时渲染未完成。 List.js1import React from &#39;react&#39;;2import &#39;.&#x2F;index.css&#39;;34&#x2F;&#x2F; 改变当前选中的change方法(参数：当前点击的text值以及渲染的所有数组值)5const changeDone &#x3D; (id, all) &#x3D;&gt; &#123;6 all.forEach(item &#x3D;&gt; &#123;7 if(item.id &#x3D;&#x3D;&#x3D; id) &#123;8 item.done &#x3D; !item.done;9 &#125;10 &#125;)11 &#x2F;&#x2F; 返回新的渲染数组(直接返回all的话不会进行更新，会造成修改的数据丢失)12 return [...all];13&#125;1415&#x2F;&#x2F; 删除某一个事件的方法16const deleteOne &#x3D; (id, all) &#x3D;&gt; &#123;17 let newArr &#x3D; all.filter(item &#x3D;&gt; item.id !&#x3D;&#x3D; id);18 return [...newArr];19&#125;2021&#x2F;&#x2F; 根据条件过滤todo的方法22const filterTodo &#x3D; (value, all) &#x3D;&gt; &#123;23 switch (value) &#123;24 case 1:25 return all;26 case 2:27 return all.filter(item &#x3D;&gt; item.done &#x3D;&#x3D;&#x3D; true);28 case 3:29 return all.filter(item &#x3D;&gt; item.done &#x3D;&#x3D;&#x3D; false);30 default:31 throw new Error(&#39;过滤条件错误&#39;);32 &#125;33&#125;3435function List(props) &#123;36 let &#123; renderValue, todoThings, setTodo &#125; &#x3D; props;37 &#x2F;&#x2F; 根据renderValue过滤一次todoThings数组38 let renderArr &#x3D; filterTodo(renderValue, todoThings);39 return (40 &lt;ul className&#x3D;&#39;listWrap&#39;&gt;41 &#123;42 renderArr.length ?43 renderArr.map((item, idx) &#x3D;&gt; &#123;44 return (45 &lt;li key&#x3D;&#123;idx&#125; style&#x3D;&#123;&#123;width: &#39;200px&#39;&#125;&#125;&gt;46 &lt;div47 style&#x3D;&#123;&#123;48 textDecoration: item.done ? &#39;line-through&#39; : &#39;none&#39;,49 float: &#39;left&#39;,50 &#125;&#125;51 onClick&#x3D;&#123;() &#x3D;&gt; setTodo(changeDone(item.id, todoThings))&#125;52 &gt;&#123;item.text&#125;&lt;&#x2F;div&gt;53 &lt;div54 className&#x3D;&#39;close&#39;55 onClick&#x3D;&#123;() &#x3D;&gt; setTodo(deleteOne(item.id, todoThings))&#125;56 &gt;X&lt;&#x2F;div&gt;57 &lt;&#x2F;li&gt;58 )59 &#125;) :60 null61 &#125;62 &lt;&#x2F;ul&gt;63 );64&#125;6566export default List; list 里面涉及到对事件的删除，事件已完成与未完成之间的状态切换，以及根据信号量渲染事件，所以接收了 3 个变量（信号量 state， 事件 state 和改变事件的方法）有一点需要注意：在 state 为对象的时候，直接去改变对象里面的某个数据再返回当前对象并不会触发更新，会造成数据丢失，一定要返回一个新的对象，才能被 react 检测到。 .eslintrc1&#123;2 &quot;plugins&quot;: [3 &quot;react-hooks&quot;4 ],5 &quot;rules&quot;: &#123;6 &quot;react-hooks&#x2F;rules-of-hooks&quot;: &quot;error&quot;,7 &quot;react-hooks&#x2F;exhaustive-deps&quot;: &quot;warn&quot;8 &#125;9&#125; 这个是检测 react hook 语法的插件，官方推荐在代码中加上此插件。 最后该 demo 只是用来体会 hook 语法之间数据定义，数据传递的过程，在样式及某些功能上存在着一些缺陷，这里就不再大幅度修改。该项目的 github 线上地址：http://chenchunyang.site/hook-todolist/build/","categories":[{"name":"react","slug":"react","permalink":"http://chenchunyang.site/categories/react/"}],"tags":[{"name":"hook语法","slug":"hook语法","permalink":"http://chenchunyang.site/tags/hook%E8%AF%AD%E6%B3%95/"}]},{"title":"开发中关于transfrom缩放的一次应用","slug":"11-About-the-use-of-transform","date":"2019-06-21T04:01:08.000Z","updated":"2019-12-25T07:55:45.851Z","comments":true,"path":"2019/06/21/11-About-the-use-of-transform/","link":"","permalink":"http://chenchunyang.site/2019/06/21/11-About-the-use-of-transform/","excerpt":"背景在做项目上的登陆注册页面时，设计图给的是 1920×1080 的尺寸，当后来要加一行表单时就遇到了一个显示上问题。","text":"背景在做项目上的登陆注册页面时，设计图给的是 1920×1080 的尺寸，当后来要加一行表单时就遇到了一个显示上问题。 如下图：在之前一版没加‘验证码’表单项时，在笔记本上还能够勉强都显示出来，但是再加一行过后，明显已经超过浏览器的显示范围了，这对于用户体验来说很不友好。其实如果是在正规的 1920*1080 分辨率的屏幕下，显示效果很好，但是笔记本用户一般会对电脑显示进行放大，且一般为 125%，所以就会出现这种情况。 思考最开始考虑针对这个分辨率再写一套媒体查询的样式，或者全改为自适应尺寸大小，但是这样做工作量其实比较大，也不是很好改。后来考虑能不能单独对这个页面进行缩小显示，便找到了 zoom 属性，单独设置右边表单盒子的 zoom。渲染的时候先用 window.document.documentElement.clientHeight 读取到页面的高度，当这个高度小于 950 的时候，加上 zoom：0.8，但是这时候又遇到了一个新的问题：在 ie 和 chrome 下支持，在 firefox 下不起作用。于是马上打开百度搜索，在看过几个答案过后，得出一个结论：zoom 确实存在兼容性问题，但是可以用 transform: scale(0.8)搭配 transform-origin：‘center center’来解决 firefox 下不起作用的问题（不过最后因为不用考虑 ie 低版本，所以直接舍弃掉 zoom 属性，统一用 transform：scale(0.8)以及 transform-origin：‘center center’来改变样式）。最后在 125%缩放的笔记本显示效果如下：","categories":[{"name":"css","slug":"css","permalink":"http://chenchunyang.site/categories/css/"}],"tags":[{"name":"兼容性","slug":"兼容性","permalink":"http://chenchunyang.site/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"}]},{"title":"基于fetch封装的下载文件代码","slug":"10-Based-on-fetch-packaging-method","date":"2019-05-20T10:16:48.000Z","updated":"2019-12-25T07:54:45.054Z","comments":true,"path":"2019/05/20/10-Based-on-fetch-packaging-method/","link":"","permalink":"http://chenchunyang.site/2019/05/20/10-Based-on-fetch-packaging-method/","excerpt":"背景公司的一个项目当中，之前的所有请求并不需要在请求头上都加上 token，不需要验证，但是最近后台逻辑改了，要都加上 token。大多数请求都还好，直接加上就可以了，但是下载文件之前是使用 a 标签来做的，a 标签又没有办法直接加 headers，那么只能考虑用另一种方法模拟，再加上项目中请求基本都是用的 fetch，于是自然是想着基于 fetch 封装一个下载文件的方法。","text":"背景公司的一个项目当中，之前的所有请求并不需要在请求头上都加上 token，不需要验证，但是最近后台逻辑改了，要都加上 token。大多数请求都还好，直接加上就可以了，但是下载文件之前是使用 a 标签来做的，a 标签又没有办法直接加 headers，那么只能考虑用另一种方法模拟，再加上项目中请求基本都是用的 fetch，于是自然是想着基于 fetch 封装一个下载文件的方法。 1import fetch from 'dva/fetch';2import &#123; message &#125; from 'antd';34// 检查状态码的函数5function checkStatus(res) &#123;6 if (res &amp;&amp; res.status === 401) &#123;7 message.error('下载出错，查看控制台', 2);8 &#125;910 if (res.status &gt;= 200 &amp;&amp; res.status &lt; 300) &#123;11 return res;12 &#125;1314 const error = new Error(res.statusText);15 error.res = res;16 throw error;17&#125;1819/**20 * 下载文件的主函数21 *22 * @param &#123;string&#125; url 请求地址23 * @param &#123;string&#125; fileName 文件名24 * @param &#123;string&#125; ext 扩展名25 *26 */27function downloadFile(url, fileName, ext) &#123;28 fetch(url, &#123;29 headers: &#123;30 Authorization: localStorage.getItem('token')31 &#125;32 &#125;)33 .then(checkStatus)34 .then(res =&gt;35 res.blob().then(blob =&gt; &#123;36 let a = document.createElement('a');37 let url = window.URL.createObjectURL(blob);38 let filename = `$&#123;fileName&#125;.$&#123;ext&#125;`;39 a.href = url;40 a.download = filename;41 a.click();42 window.URL.revokeObjectURL(url);43 &#125;)44 );45&#125;4647export default &#123;48 downloadFile49&#125;;","categories":[{"name":"fetch","slug":"fetch","permalink":"http://chenchunyang.site/categories/fetch/"}],"tags":[{"name":"封装","slug":"封装","permalink":"http://chenchunyang.site/tags/%E5%B0%81%E8%A3%85/"}]},{"title":"gulp工程化及一些常用插件的使用","slug":"09-Engineering-of-gulp","date":"2018-11-26T02:21:08.000Z","updated":"2019-12-25T07:53:43.165Z","comments":true,"path":"2018/11/26/09-Engineering-of-gulp/","link":"","permalink":"http://chenchunyang.site/2018/11/26/09-Engineering-of-gulp/","excerpt":"概念所谓的工程化就是将写完的代码进行压缩合并等操作。gulp 是一个工程化工具，代码在书写完毕之前，需要有回车换行空白符等内容。但是一旦书写完毕，交给浏览器运行时，这些内容没有用。需要移除。此时有两种方案：","text":"概念所谓的工程化就是将写完的代码进行压缩合并等操作。gulp 是一个工程化工具，代码在书写完毕之前，需要有回车换行空白符等内容。但是一旦书写完毕，交给浏览器运行时，这些内容没有用。需要移除。此时有两种方案： 1、人工移除，就是由人手工删除回车、换行、空白符。2、使用工具移除。 Gulp 就是这样的一个工具，本质上，gulp 就是一个 NodeJS 的第三方模块。 下载 第一次下载： npm install gulp 本地安装 提供模块文件第二次下载： npm install gulp -g 全局安装 提供 gulp 命令 配置文件gulp 的配置文件名是gulpfile.js，用于决定处理哪些模块，以及如何处理。写完之后，就可以调用 gulp 指令执行了。 APIgulp 是一个模块，在代码中被引入之后得到一个对象，该对象一共有 5 个 API。 gulp.task gulp.src pipe gulp.dest gulp.watch gulp.task用于定义任务 语法：gulp.task(taskName, handler);taskName: 任务名称。handler: 对应的任务函数。还可以是数组，如果是数组，数组内的成员是其它任务的名称。 default 是具备特殊含义的任务名。表示默认、缺省的意思。是所有任务的开始入口。上面的定义任务表示当任务开始的时候执行的是 aaa 和 bbb 任务。 gulp.src该方法用于将物理文件转换成文件流。 gulp.src(filePath);filePath: 表示文件路径的值 有三个可选项 可以是字符串 表示单个文件 可以是数组 表示多个文件 可以是 glob 表达式 返回值：一个对象 该对象所拥有的方法可以决定如何操作目标文件 gulp.pipe该方法不是 gulp 拥有的，而是 gulp.src 执行之后的返回值对象所拥有的。该方法用于定义一次操作。如果有多次操作，那么需要多次调用 pipe 方法。红色部分，表示定义了一个操作。蓝色部分，表示具体操作。 gulp.dest该方法用于将流文件转换成物理文件，与 src 正好相反。 gulp.dest(path);path: 目录路径 表示发布的地址 gulp.watch该方法用于监听文件，触发任务。当我们一边写代码，一边工程化时，如果每一次修改代码都需要自己调用 gulp 命令，会显得很繁琐,此时我们可以使用 gulp.watch. gulp.watch(target, handler);target: 目标文件三个可选项： 文件路径字符串、数组、glob 表达式handler: 当目标文件发生改变时，执行的任务两个可选项： 函数、数组 以上代码表示：当./source/里的所有 js 文件中任一文件发生变化时，调用 update 任务。 插件gulp 本身只有 5 个 API。只依靠它自己，基本什么工程化行为都无法完成，但是它具备大量的插件（这里介绍 7 个插件）。 压缩 js 插件名称： gulp-uglify作用：压缩 JS下载：npm install gulp-uglify 压缩 css 插件名称：gulp-clean-css作用：压缩 CSS下载：npm install gulp-clean-css 压缩 html 插件名称：gulp-minify-html作用：压缩 html下载：npm install gulp-minify-html 合并 插件名称：gulp-concat作用：合并文件下载：npm install gulp-concat 重命名 模块名称: gulp-rename作用: 重命名文件下载: npm install gulp-rename 压缩图片 插件名称：gulp-imagemin作用： 压缩图片下载： npm install gulp-imagemin 书写校验 插件名称：gulp-jslint作用： 检验 js 格式下载： npm install gulp-jslint格式规范： if 右边 一定要有一个空格 function 的参数列表右圆括号右侧必须要有一个空格 换行使用四个空格缩进 使用严格模式 尾巴不能有空格 等等…… 检验有错误：检验通过：","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://chenchunyang.site/categories/nodejs/"},{"name":"gulp","slug":"nodejs/gulp","permalink":"http://chenchunyang.site/categories/nodejs/gulp/"}],"tags":[{"name":"常用插件","slug":"常用插件","permalink":"http://chenchunyang.site/tags/%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"}]},{"title":"记录关于路由拦截的小坑","slug":"08-Route-interception","date":"2018-11-23T06:07:44.000Z","updated":"2019-12-25T07:53:03.870Z","comments":true,"path":"2018/11/23/08-Route-interception/","link":"","permalink":"http://chenchunyang.site/2018/11/23/08-Route-interception/","excerpt":"今天在用 nodejs 写登录注册时候遇到了一个问题，我想实现用户在注册时，如果用户名不为空，失去焦点后发送 ajax 与 mongo 数据库中的数据进行对比，数据库中没有用户输入的用户名则显示可用，效果如下：","text":"今天在用 nodejs 写登录注册时候遇到了一个问题，我想实现用户在注册时，如果用户名不为空，失去焦点后发送 ajax 与 mongo 数据库中的数据进行对比，数据库中没有用户输入的用户名则显示可用，效果如下： 虽然我后来已经实现了，但是当我不知道又弄了哪里的时候，数据不能从后台返回来了。触发验证用户名的事件后，并没有对应的事件发生。一开始，我怀疑是后台“检查用户名”的接口有问题，但是扫了一遍过后并没有发现哪里不对，我又尝试着去后台打印要接收的用户名，结果后台根本没有接收到，那也就是说前台可能并没有发送过来，前台又找了很久，理了一遍逻辑，也没有发现问题= =，不知所措的我在网页中打开了 F12，看看 network 中触发事件的时候会有什么请求，结果发现除了一个 checkName 请求（我们需要的），还多了一个 login 请求，这是什么东西？？请求中多了一个 login，那大概可以确定是这个影响了检查用户名，回想起来之前在”注册”里写的逻辑代码并没有请求这个= =。又看了该页面前端和后端的逻辑，还是没有发现在哪个地方请求了它。 就在我抓耳挠腮时，我突然想到了之前又配置了一个路由拦截器，如果 session 里面没有用户登录的数据，则让他直接跳转到登录页面，于是我就在路由配置里把下面这段代码注释掉了：果然，一切恢复正常，接着又仔细思考了一下原因：我写这个路由拦截器的目的是防止用户没有登录就直接通过输入 url 进入其他页面，拦截的是 get 请求，同时如果我没有登录，在注册验证用户名的时候，同样也是一个 get 请求，那么该拦截器就会对这个请求进行拦截，并尝试跳转到 login 界面。在思考清楚了问题过后，我确定再加一个判断，不拦截验证用户名的 get 请求：工具函数：升级过后的路由拦截器： 心得体会：1、多用 F12，在无法确定代码问题的时候，它真的很好用。2、路由拦截时不能过于暴力，如果项目很大，考虑的情况比较多的话，那就要防止拦截到不该拦截的路由。 November 26, 2018 11:22 AM 更新其实还有一种更简单的办法，就是将不需要拦截的请求放到拦截器的上面，因为 js 是从上往下执行的，只要让它能在拦截器的前面执行就可以。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://chenchunyang.site/categories/nodejs/"}],"tags":[{"name":"路由拦截","slug":"路由拦截","permalink":"http://chenchunyang.site/tags/%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA/"}]},{"title":"处理报错：Router.use() requires a middleware function but got a string","slug":"07-Requires-a-middleware-function-but-got-a-string","date":"2018-11-16T12:58:20.000Z","updated":"2019-12-25T07:52:21.513Z","comments":true,"path":"2018/11/16/07-Requires-a-middleware-function-but-got-a-string/","link":"","permalink":"http://chenchunyang.site/2018/11/16/07-Requires-a-middleware-function-but-got-a-string/","excerpt":"今天在配置 nodejs 时出现了一个问题如下图所示：","text":"今天在配置 nodejs 时出现了一个问题如下图所示： 大意是这个 use 方法需要一个中间件函数，但是它得到的是一个字符串。一开始我考虑是我配置的路由 js 文件可能出了点问题，因为错误信息中有个 Router。我就对 router 里的 js 文件进行查错：但是经过搜索，这么引入是没有问题的，于是我在 app.js 中把配置路由的代码给注释掉了，看能不能开启服务器（不配置路由正常情况下也是能够开启服务器的），结果还是同样的报错。我又试着把配置服务器的注释掉，居然不报错了，看来就是 conf 文件夹里的 js 文件有问题，进入查看。原来我在配置模板的时候，调用错了方法，用的 use 方法，use 里面两个值都是字符串导致报错，正确的配置应该是使用 set 方法。**心得：use 方法里面不能跟字符串，出现这个报错检查 use 里的参数即可。书写代码的时候一定要仔细，有可能一个小地方就导致了程序的崩溃。**","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://chenchunyang.site/categories/nodejs/"}],"tags":[{"name":"报错处理","slug":"报错处理","permalink":"http://chenchunyang.site/tags/%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"}]},{"title":"原生实现ES5数组方法","slug":"06-Array-method-of-es5","date":"2018-11-13T16:28:48.000Z","updated":"2019-12-25T07:51:19.934Z","comments":true,"path":"2018/11/14/06-Array-method-of-es5/","link":"","permalink":"http://chenchunyang.site/2018/11/14/06-Array-method-of-es5/","excerpt":"indexOf、lastIndexOf1// indexOf2if (!Array.prototype.indexOf) &#123;3 Array.prototype.indexOf = function(item) &#123;4 for (var i = 0; i &lt; this.length; i++) &#123;5 if (this[i] === item) &#123;6 return i;7 &#125;8 &#125;9 return -1;10 &#125;;11&#125;","text":"indexOf、lastIndexOf1// indexOf2if (!Array.prototype.indexOf) &#123;3 Array.prototype.indexOf = function(item) &#123;4 for (var i = 0; i &lt; this.length; i++) &#123;5 if (this[i] === item) &#123;6 return i;7 &#125;8 &#125;9 return -1;10 &#125;;11&#125; 1// lastIndexOf2if (!Array.prototype.lastIndexOf) &#123;3 Array.prototype.lastIndexOf = function(item) &#123;4 for (var i = this.length - 1; i &gt;= 0; i--) &#123;5 if (this[i] === item) &#123;6 return i;7 &#125;8 &#125;9 return -1;10 &#125;;11&#125; forEach、map1// forEach2if (!Array.prototype.forEach) &#123;3 Array.prototype.forEach = function(fn) &#123;4 for (var i = 0; i &lt; this.length; i++) &#123;5 fn(this[i], i, this);6 &#125;7 &#125;;8&#125; 1// map2if (!Array.prototype.map) &#123;3 Array.prototype.map = function(fn) &#123;4 var result = [];5 for (var i = 0; i &lt; this.length; i++) &#123;6 result.push(fn(this[i], i, this));7 &#125;8 return result;9 &#125;;10&#125; fill1// fill2if (!Array.prototype.fill) &#123;3 Array.prototype.fill = function(item) &#123;4 for (var i = 0; i &lt; this.length; i++) &#123;5 this[i] = item;6 &#125;7 return this;8 &#125;;9&#125; some、every1// some2if (!Array.prototype.some) &#123;3 Array.prototype.some = function(fn) &#123;4 for (var i = 0; i &lt; this.length; i++) &#123;5 if (fn(this[i], i, arr)) &#123;6 return true;7 &#125;8 &#125;9 return false;10 &#125;;11&#125; 1// every2if (!Array.prototype.every) &#123;3 Array.prototype.every = function(fn) &#123;4 for (var i = 0; i &lt; this.length; i++) &#123;5 if (!fn(this[i], i, arr)) &#123;6 return false;7 &#125;8 &#125;9 return true;10 &#125;;11&#125; filter1// filter2if (!Array.prototype.filter) &#123;3 Array.prototype.filter = function(fn) &#123;4 var result = [];5 for (var i = 0; i &lt; this.length; i++) &#123;6 if (fn(this[i], i, this)) &#123;7 result.push(this[i]);8 &#125;9 &#125;10 return result;11 &#125;;12&#125; reduce、reduceRight1// reduce2if (!Array.prototype.reduce) &#123;3 Array.prototype.reduce = function(fn) &#123;4 var result = this[0];5 for (var i = 1; i &lt; this.length; i++) &#123;6 result = fn(result, this[i], i, arr);7 &#125;8 return result;9 &#125;;10&#125; 1// reduceRight2if (!Array.prototype.reduceRight) &#123;3 Array.prototype.reduceRight = function(fn) &#123;4 var result = this[this.length - 1];5 for (var i = this.length - 2; i &gt;= 0; i--) &#123;6 result = fn(result, this[i], i, arr);7 &#125;8 return result;9 &#125;;10&#125;","categories":[{"name":"ES5","slug":"ES5","permalink":"http://chenchunyang.site/categories/ES5/"}],"tags":[{"name":"兼容","slug":"兼容","permalink":"http://chenchunyang.site/tags/%E5%85%BC%E5%AE%B9/"},{"name":"数组方法","slug":"数组方法","permalink":"http://chenchunyang.site/tags/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"}]},{"title":"迭代器（jq、underscore、es5、自建）","slug":"05-Understanding-of-iterators","date":"2018-11-03T13:12:31.000Z","updated":"2019-12-25T07:50:31.871Z","comments":true,"path":"2018/11/03/05-Understanding-of-iterators/","link":"","permalink":"http://chenchunyang.site/2018/11/03/05-Understanding-of-iterators/","excerpt":"Jq 中的迭代器dom 结构","text":"Jq 中的迭代器dom 结构 js 方法 输出（省略后面重复部分） 定义一个数组及遍历输出：（this 的实质就是每一次遍历到的 value 的数字包装类型） underscore 中的迭代器定义一个数组及遍历输出： es5 中的迭代器定义一个数组及遍历输出： 自己的迭代器目的定义一个函数，该函数可以实现对数组和对象的遍历。 1/**2 * each函数 实现迭代器3 * @target 要遍历的目标4 * @fn 要执行的函数5 **/6function each(target, fn) &#123;7 // 判断传递的target是数组还是对象8 if (target instanceof Array) &#123;9 // 说明传递的是数组10 for (var i = 0; i &lt; target.length; i++) &#123;11 // 执行fn12 fn.call(target[i], target[i], i, target);13 &#125;14 &#125; else if (Object.prototype.toString.call(target) === '[object Object]') &#123;15 for (var i in target) &#123;16 // 传递二个参数17 fn.call(target[i], target[i], i);18 &#125;19 &#125;20&#125; 数组遍历结果 对象遍历结果","categories":[{"name":"归纳","slug":"归纳","permalink":"http://chenchunyang.site/categories/%E5%BD%92%E7%BA%B3/"}],"tags":[{"name":"迭代器方法","slug":"迭代器方法","permalink":"http://chenchunyang.site/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%96%B9%E6%B3%95/"}]},{"title":"观察者模式结合seajs模块化的小实例","slug":"04-Modular-example","date":"2018-10-30T09:20:33.000Z","updated":"2019-12-25T07:49:30.637Z","comments":true,"path":"2018/10/30/04-Modular-example/","link":"","permalink":"http://chenchunyang.site/2018/10/30/04-Modular-example/","excerpt":"实例演示首先我们打算实现如下图所示的效果：","text":"实例演示首先我们打算实现如下图所示的效果： 不难，一个人写很简单，这里不是想讨论在一个 js 当中该怎么写出来，而是主要体会模块化开发多人协作的过程。 分析我们把这个需求分给三个人做： 1.小 a 做”消息数量“ 2.小 b 做”中部消息内容“ 3.小 c 做”文本框及按钮“如果一个人做，那么可以很容易控制先做什么后做什么，但是三个人来做，每个人的进度都不同，那么模块之间该如何互相通信这是一个很重要的问题。 初步设想由于在 seajs 中，每个模块之间都是独立互不干扰的，换句话说，模块与模块之间是相互访问不到的，想让它们通信的话，初步设想在每个模块中向全局暴露内容变量。虽然这么做确实能够实现，但是也有问题，因为我们在设计程序的时候，原则就是尽量减少全局变量，每多一个全局变量，就会多占用一些资源，并且存在内存泄漏的隐患，影响性能。 再次假设既然变量太多了，那我们看看能不能减少变量，因为在 js 中，对象里面是可以写方法的。想到这里，再次尝试，定义一个 ob 对象，里面写方法，然后在每个模块里面分别调用这个对象的方法，确实可行。但是这样就完美了吗？答案是 no，当在全局中直接暴露了这个存有方法的对象，人为地进行修改很方便，很不安全。 继续假设想到这里，问题就来了，怎么做才能避免直接就能够修改 ob 对象？对，没错，利用 IIFE 自执行函数把它包一下。 1// 定义对象2var Observer = (function() &#123;3 // 定义真正的观察者4 var ob = &#123;&#125;;5 // 定义返回接口6 return &#123;7 /**8 * on方法要用于向观察者对象中添加事件9 * @type 字符串 表示事件名称10 * @fn 函数 表示事件函数11 **/12 on: function(type, fn) &#123;13 ob[type] = fn;14 &#125;,15 /**16 * trigge方法用于触发观察者对象中的事件17 * @type 要触发的事件名称18 **/19 trigger: function(type, val) &#123;20 ob[type](val);21 &#125;22 &#125;;23&#125;)(); 但是现在在全局中还是有一个 Observer 变量，现在我们也把它放入模块文件中。 1// 定义模块2define(function(require, exports, module) &#123;3 // 定义对象4 var Observer = (function() &#123;5 // 定义真正的观察者6 var ob = &#123;78 &#125;;9 // 定义返回接口10 return &#123;11 /**12 * on方法要用于向观察者对象中添加事件13 * @type 字符串 表示事件名称14 * @fn 函数 表示事件函数15 **/16 on: function(type, fn) &#123;17 ob[type] = fn;18 &#125;,19 /**20 * trigge方法用于触发观察者对象中的事件21 * @type 要触发的事件名称22 **/23 trigger: function(type, val) &#123;24 ob[type](val);25 &#125;26 &#125;27 // 向外暴露功能28 module.exports = Observer;29 &#125;)(); 最终形态我们发现在第三个模块的点击事件中，里面的触发事件写了两个，一个是模块一中定义的消息数量++，一个是模块二中的 li 元素增加，既然它们是点击按钮过后一起执行的，并且具有相同的语义，那我们能否把这两个合并成一个呢？确实也可以，也就是说书写一个 trigger 执行函数要同时触发两个定义函数，那么两个定义函数的名字必须要相同，才能用一个 trigger 函数来触发。但是如果使用之前的”观察者“，在用同一个名字定义了第一个模块和第二个模块中的事件后，触发第三个模块中的事件，会发现其中一个模块函数并不能被触发，因为当给一个对象设置同名属性的时候，会有一个覆盖的现象。那么这时候我们可以考虑利用数组，如果对象存在这个属性方法，那么把后一个属性方法 push 进数组，如果不存在，直接定义这个属性方法，并且存在数组中。后面的事件处理函数也要改成遍历数组处理定义函数，这样便可以达到简化的目的。升级过后的观察者对象如下： 1var Observer = (function() &#123;2 // 定义真正的观察者3 var ob = &#123;45 &#125;;6 // 定义返回接口7 return &#123;8 on: function(type, fn) &#123;9 // 判断当前type是不是一个数组， 如果是数组说明被使用过，就可以直接push进去10 if (ob[type]) &#123;11 ob[type].push(fn);12 &#125; else &#123;13 // 说明不是数组， 将其变为数组14 ob[type] = [fn];15 &#125;16 &#125;,17 trigger: function(type, val) &#123;18 // 循环执行19 for (var i = 0; i &lt; ob[type].length; i++) &#123;20 ob[type][i](val);21 &#125;22 &#125;23 &#125;)(); 最后再贴上最终完成的其他三个模块的文件代码： 模块一 1// 定义模块2define(function(require, exports, module) &#123;3 // 引入工具模块4 var Observer = require('modules/tools');5 // 获取元素6 var num = document.getElementById('num');7 // 监听添加消息事件8 Observer.on('add', function() &#123;9 num.innerHTML = +num.innerHTML + 1;10 &#125;);11 // 监听减少消息事件12 Observer.on('remove', function() &#123;13 num.innerHTML = +num.innerHTML - 1;14 &#125;);15&#125;); 模块二 1// 定义模块2define(function(require, exports, module) &#123;3 // 引入工具模块4 var Observer = require('modules/tools');5 // 获取元素6 var ul = document.getElementById('list');7 // 监听消息添加事件8 Observer.on('add', function(val) &#123;9 // 创建元素10 var li = document.createElement('li');11 var textNode = document.createTextNode(val);12 var span = document.createElement('span');13 // 添加类名14 span.className = 'close';15 // 添加内部文本16 span.innerHTML = '&amp;times;';17 // 添加点击事件18 span.onclick = function() &#123;19 ul.removeChild(this.parentNode);20 // 通知第一个模块，消息数量要减一21 Observer.trigger('remove');22 &#125;;23 // 上树24 li.appendChild(textNode);25 li.appendChild(span);26 ul.appendChild(li);27 &#125;);28&#125;); 模块三 1// 定义模块2define(function(require, exports, module) &#123;3 // 引入工具模块4 var Observer = require('modules/tools');5 // 获取元素6 var words = document.getElementById('words');7 var btn = document.getElementById('btn');8 // 添加点击事件9 btn.onclick = function() &#123;10 // 获取用户输入的内容11 var val = words.value;12 // 触发事件13 Observer.trigger('add', val);14 &#125;;15&#125;);","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://chenchunyang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"观察者模式","slug":"观察者模式","permalink":"http://chenchunyang.site/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式——委托模式","slug":"03-Delegation-mode","date":"2018-10-30T03:45:53.000Z","updated":"2019-12-25T07:48:36.110Z","comments":true,"path":"2018/10/30/03-Delegation-mode/","link":"","permalink":"http://chenchunyang.site/2018/10/30/03-Delegation-mode/","excerpt":"场景引入假设现在我们要做一个需求，如下图：","text":"场景引入假设现在我们要做一个需求，如下图： 根据效果我们需要完成的有三件事情： 点击按钮，添加一个 Li 元素 点击哪个 Li 就让哪个变色 点击哪个叉（span 元素）就让它对应的父元素消失 顺向思维如果按照一般的思路，可能我们会像下面这么写： 1// 给按钮添加点击事件2btn.onclick = function() &#123;3 // 创建长条元素li4 var li = document.createElement('li');5 // 创建了元素立马加上点击变色事件6 li.onclick = function() &#123;7 this.style.backgroundColor = 'red';8 &#125;;9 // 创建小叉叉元素span10 var span = document.createElement('span');11 // 创建后同样马上加上移除事件12 span.onclick = function() &#123;13 ul.removeChild(this.parentNode);14 &#125;;15 // 添加span的内部文本16 span.innerHTML = '&amp;times;';17 // 上树18 li.appendChild(span);19 ul.appendChild(li);20&#125;; 上面是给添加出来的元素写好了效果，但是针对于原来就在页面上存在的元素，我们还需要循环对它们添加事件。 1for (var i = 0; i &lt; lis.length; i++) &#123;2 // 给所有li添加点击事件3 lis[i].onclick = function() &#123;4 this.style.backgroundColor = 'red';5 &#125;;6&#125; 1for (var i = 0; i &lt; spans.length; i++) &#123;2 // 给所有span添加点击事件3 spans[i].onclick = function() &#123;4 ul.removeChild(this.parentNode);5 &#125;;6&#125; 至此，效果就已经符合需求了。但是现在有一个问题，每次创建了一个新的元素，我们就给它新定义一个事件，也对存在的元素循环添加了事件，虽然看起来事件都一样，都是同一个事件，但是它们在内存中的地址相同吗?很显然它们并不是同一个，每次添加事件都会在内存上重新开辟一块地址来存放事件，虽然看起来一样，但是它们的地址并不一样。可以想象成现在有 3 个人，他们分别买了一套房子，房子里装修的一模一样，他们房子的占地面积就是 3 套的占地面积；现在还有另外三个人，他们合租在一起，这时他们的占地面积就是 1 套的面积。那么我们可能会做如下优化： 1btn.onclick = function() &#123;2 // 创建元素3 var li = document.createElement('li');4 li.onclick = li_click;5 var span = document.createElement('span');6 span.onclick = span_click;7 // 添加span的内部文本8 span.innerHTML = '&amp;times;';9 // 上树10 li.appendChild(span);11 ul.appendChild(li);12&#125;;13for (var i = 0; i &lt; lis.length; i++) &#123;14 // 给所有li添加点击事件15 lis[i].onclick = li_click;16&#125;17for (var i = 0; i &lt; spans.length; i++) &#123;18 // 给所有span添加点击事件19 spans[i].onclick = span_click;20&#125;21// 把事件提取出来，在内存上占用一个地址22function li_click() &#123;23 this.style.backgroundColor = 'red';24&#125;25function span_click() &#123;26 ul.removeChild(this.parentNode);27&#125; 就买“两套房子”，谁要使用的话就给谁“配钥匙”，这样就减少了内存的消耗。 继续优化这时候继续思考，当我们点击叉子符号的时候，实际上只是对当前的 li 进行了移除，不在页面当中显示了而已，实际上在内存当中，它仍然保持着对点击事件的引用，也就是说它仍然拿着房子钥匙，那部分内存就无法被回收，这就是内存泄漏（无法被重复利用的内存）的隐患。那我们实际上可以考虑另外一种实现方式： 1// 给父元素添加点击事件2ul.onclick = function(e) &#123;3 // 通过e.target属性判断点击是哪个元素4 // console.log(e.target);5 if (e.target.nodeName.toLowerCase() === 'li') &#123;6 // 改变背景色7 e.target.style.backgroundColor = 'red';8 &#125; else if (e.target.nodeName.toLowerCase() === 'span') &#123;9 // 移除对应的父元素10 ul.removeChild(e.target.parentNode);11 &#125;12&#125;;13// 点击btn添加li14btn.onclick = function() &#123;15 ul.innerHTML += '&lt;li&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/li&gt;';16&#125;; btn 按钮只负责向 ul 中添加 li 和 span 元素，而其他的事件都交给 ul 元素来处理，交给了父元素来判断，这就是委托模式。综上，委托模式解决了三件事情： 减少事件的数量 预言未来的元素（不用担心后面添加的元素没有效果） 防止内存泄漏","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://chenchunyang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"委托模式","slug":"委托模式","permalink":"http://chenchunyang.site/tags/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式——登陆策略","slug":"02-Login-policy","date":"2018-10-29T16:37:23.000Z","updated":"2019-12-25T07:47:56.643Z","comments":true,"path":"2018/10/30/02-Login-policy/","link":"","permalink":"http://chenchunyang.site/2018/10/30/02-Login-policy/","excerpt":"场景引入在网页中，当我们在注册一个账号，也就是填写表单的时候，经常会看到一个效果：比如输入了用户名过后，再点击密码框想设置密码，这时网页会检测你的用户名是否合法，是否符合要求（如下图）。","text":"场景引入在网页中，当我们在注册一个账号，也就是填写表单的时候，经常会看到一个效果：比如输入了用户名过后，再点击密码框想设置密码，这时网页会检测你的用户名是否合法，是否符合要求（如下图）。 思路分析针对这个效果，我们可以对用户名输入框设置一个失去焦点的事件，并且在失去焦点的时候对输入的内容进行正则匹配，不匹配则报错。 实现过程1// 获取元素2var username = document.getElementById(\"username\");3// 失去焦点之后检测内容的合法性4username.onblur = function() &#123;5 // 获取用户输入的内容6 var val = this.value;7 // 定义正则表达式8 var reg = /^[a-zA-Z]+$/g;9 // 验证10 if (reg.test(val)) &#123;11 console.log(\"恭喜你, 通过了\");12 &#125; else &#123;13 console.log(\"请输入纯英文\");14 &#125; 这个思路还是很好想到的，但是突然有一天，我们又得到一个需求，要对 100 个表单都进行验证。虽然按照这个思路一个一个地写，一个一个地复制粘贴也没有问题，但是未免效率太低了，这时候就需要进行优化！ 优化先说说 jQery 中的运用到的策略模式，如下代码： 1&lt;script type=\"text/javascript\" src=\"js/jquery-1.7.2.js\"&gt;&lt;/script&gt;2&lt;script type=\"text/javascript\" src=\"js/jquery.easing.js\"&gt;&lt;/script&gt;3&lt;script type=\"text/javascript\"&gt;4// 使用animate函数5$(\"#box1\").animate(&#123;left: 1000&#125;, 1000, \"easeInOutBack\", function() &#123;&#125;);6$(\"#box2\").animate(&#123;left: 1000&#125;, 1000, \"easeInOutElastic\", function() &#123;&#125;);7$(\"#box3\").animate(&#123;left: 1000&#125;, 1000, \"easeInElastic\", function() &#123;&#125;);8&lt;/script&gt; 它把一些运动的方式写到了 easing.js 中，当我们去给盒子定义动画的时候不用再去一个一个书写，想用哪种效果就直接在 animate 函数第三个参数写上“名字”。按照这种想法，我们在进行表单验证时，也把特定的验证方式封装成一个对象里的方法。 1// 定义对象2var Strategy = (function() &#123;3 var s = &#123;4 chunyingwen: function(str) &#123;5 // 定义正则表达式6 var reg = /^[a-zA-Z]+$/g;7 // 验证8 if (reg.test(str)) &#123;9 return '通过';10 &#125; else &#123;11 return '请输入纯英文';12 &#125;13 &#125;,14 chunshuzi: function(num) &#123;15 // 定义正则匹配16 var reg = /^\\d+$/g;17 // 验证18 if (reg.test(num)) &#123;19 return '通过';20 &#125; else &#123;21 return '请输入纯数字';22 &#125;23 &#125;24 &#125;;25 // 定义接口26 return &#123;27 use: function(type, str) &#123;28 return s[type](str);29 &#125;30 &#125;;31&#125;)(); 接下来再进行验证的时候就简单了，用哪种方法直接引入该对象下的方法。 1// 失去焦点之后检测内容的合法性2username.onblur = function() &#123;3 var result = Strategy.use('chunshuzi', this.value);4&#125;; 所以整体来说策略模式就是把特定的方法都提取出来，封装在一个对象下的属性方法中，用哪个就提取哪个。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://chenchunyang.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"表单验证","slug":"表单验证","permalink":"http://chenchunyang.site/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"},{"name":"策略模式","slug":"策略模式","permalink":"http://chenchunyang.site/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"入坑记","slug":"01-Into-the-pit","date":"2018-10-28T13:22:02.000Z","updated":"2019-12-25T07:46:48.179Z","comments":true,"path":"2018/10/28/01-Into-the-pit/","link":"","permalink":"http://chenchunyang.site/2018/10/28/01-Into-the-pit/","excerpt":"伪前言前言听起来好像是书中才应该有的东西，但是因为这是这篇博客中的第一篇，想写个开头，实在是不知道应该用什么小标题了，于是起了个“伪前言”。我记得在大二下学期自学前端刚开始的时候，学会了一点简单的切图和布局，想做一个自己的博客，于是在腾讯云上买了一年的域名权限（花了我 10 多块大洋），还买了服务器（这个忘记怎么收费的了），跟着流程一直到了备案照相，腾讯发过来印有他们公司 logo 的幕布，但是后来又因为一些其他事情加上找实习，这件事就没再继续了，当时还以为能切个图，买个服务器弄个域名一上传就完了，结果怎么弄都没有成功。","text":"伪前言前言听起来好像是书中才应该有的东西，但是因为这是这篇博客中的第一篇，想写个开头，实在是不知道应该用什么小标题了，于是起了个“伪前言”。我记得在大二下学期自学前端刚开始的时候，学会了一点简单的切图和布局，想做一个自己的博客，于是在腾讯云上买了一年的域名权限（花了我 10 多块大洋），还买了服务器（这个忘记怎么收费的了），跟着流程一直到了备案照相，腾讯发过来印有他们公司 logo 的幕布，但是后来又因为一些其他事情加上找实习，这件事就没再继续了，当时还以为能切个图，买个服务器弄个域名一上传就完了，结果怎么弄都没有成功。 一晃过去一年多了，最近还是想有一个自己的记录笔记的地方，朋友说可以试试 hexo 在 github 上搭一个静态的，说干就干！后来搜索了很多文章，网上也有很多教程，自己就抱着试试看的态度一步一步地跟着教程走，当我刷出来它默认主题的 hello world 的页面时，我知道第一步已经成功完成了。 继续配置默认的主题配置实在是有点丑，于是又开始了愉快的百度搜索之旅，选择了一个据说是使用人数最多的一个主题 next，既然使用的人多我想它的文档应该也挺全的，后面就开始具体进行配置了。 配置主要是对两个文件进行改动，一个是主目录下的_config.yml，另一个是主题文件中的_config.yml。简单的修改过后，一个雏形已经出来了，后来又想加一个统计文章阅读次数的功能，利用的 LeanCloud 第三方工具，后面还想再开放一个评论的功能，这也需要一个第三方工具，静态网站的弊端就体现在这里了，因为自己没有实现后端，只能依赖于第三方服务商。目前点击个别导航栏会弹出 404，还没有添加页面，后面会把他们都添加上，同样还有文章的分页与折叠也需要实现一下，不然不方便阅读。最主要的还是要再申请一个域名并改变它的“this 指向“,不然看到域名总是有种寄人篱下的感觉= =。 嗯，暂时就这样吧，后面我会陆陆续续记录前端方面的学习。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://chenchunyang.site/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"入坑","slug":"入坑","permalink":"http://chenchunyang.site/tags/%E5%85%A5%E5%9D%91/"}]}]}